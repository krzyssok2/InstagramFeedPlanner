<div class="module-shade">
    <div class="module">
        <div class="cropper-wrapper" @ref="Wrapper"
             @onpointerdown="OnPointerDown"
             @onpointermove="OnPointerMove"
             @onpointerup="OnPointerUp"
             @onpointerleave="OnPointerUp"
             style="width: @(CropWidth)px; height: @(CropHeight)px;">
            <div class="crop-box"></div>
            <img @ref="ImageRef" src="@Src" class="crop-image" />
        </div>

        <div class="zoom-slider-wrapper" style="width: @(CropWidth)px;">
            <input type="range" min="0" max="100" value="@ZoomValue" @oninput="OnSliderChanged" />
        </div>

        <div class="button-container">
            <button class="module-button" @onclick="ConfirmCrop">Confirm</button>
            <button class="module-button" @onclick="() => OnCancel.InvokeAsync()">Cancel</button>
        </div>
    </div>
</div>

@implements IAsyncDisposable
@using InstagramFeedPlanner.Components
@using InstagramFeedPlanner.Models

@code {
    [Parameter] public string Src { get; set; } = "";
    [Parameter] public EventCallback<CropDataModel> OnConfirm { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public CropDataModel CropData { get; set; } = new CropDataModel();
    [Parameter] public double AspectRatio { get; set; } = 0.75; // width/height ratio
    [Parameter] public double PreferredWidth { get; set; } = 400; // Base size preference
    [Parameter] public double ViewportPadding { get; set; } = 0.1; // 10% padding around viewport
    [Parameter] public double ZoomRange { get; set; } = 3.0; // Max zoom is MinScale * ZoomRange

    private ElementReference ImageRef;
    private ElementReference Wrapper;

    private double ZoomValue { get; set; } = 0;
    private double Scale { get; set; } = 1;
    private double MinScale { get; set; } = 1;
    private double PosX { get; set; } = 0;
    private double PosY { get; set; } = 0;
    private bool IsDragging { get; set; } = false;
    private double StartX { get; set; }
    private double StartY { get; set; } = 0;
    private double ImgWidth { get; set; }
    private double ImgHeight { get; set; }
    private double CropWidth { get; set; }
    private double CropHeight { get; set; }

    [Inject] private IJSRuntime JS { get; set; } = default!;

    private DotNetObjectReference<AspectCropper>? dotNetRef;
    private bool isDisposed = false;

    // Derived properties
    private double PreferredHeight => PreferredWidth / AspectRatio;
    private double ViewportSafeWidth(double windowWidth) => windowWidth * (1 - ViewportPadding * 2);
    private double ViewportSafeHeight(double windowHeight) => windowHeight * (1 - ViewportPadding * 2);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            var originalSize = GetOriginalPreviewSize();

            await CalculateOptimalSize();
            await JS.InvokeVoidAsync("setupWindowResizeListener", dotNetRef);
            StateHasChanged();
            await Task.Delay(10);
            await InitializeCropper(originalSize.width, originalSize.height);
        }
    }

    private (double width, double height) GetOriginalPreviewSize()
    {
        var width = CropData.PreviewWidth > 0 ? CropData.PreviewWidth : PreferredWidth;
        var height = CropData.PreviewHeight > 0 ? CropData.PreviewHeight : PreferredHeight;
        return (width, height);
    }

    private async Task CalculateOptimalSize()
    {
        try
        {
            var windowSize = await JS.InvokeAsync<WindowSize>("getWindowSize");
            var maxWidth = ViewportSafeWidth(windowSize.Width);
            var maxHeight = ViewportSafeHeight(windowSize.Height);

            // Try preferred size first
            var width = PreferredWidth;
            var height = PreferredHeight;

            // Scale down if too big for viewport
            if (width > maxWidth)
            {
                width = maxWidth;
                height = width / AspectRatio;
            }

            if (height > maxHeight)
            {
                height = maxHeight;
                width = height * AspectRatio;
            }

            CropWidth = width;
            CropHeight = height;
        }
        catch
        {
            CropWidth = PreferredWidth;
            CropHeight = PreferredHeight;
        }
    }

    private async Task OnSliderChanged(ChangeEventArgs e)
    {
        var oldScale = Scale;
        ZoomValue = Convert.ToDouble(e.Value);
        var newScale = MinScale + ((MinScale * ZoomRange - MinScale) * (ZoomValue / 100));

        // Center zoom on crop box center
        var centerX = CropWidth / 2.0;
        var centerY = CropHeight / 2.0;

        // Keep same image point under center during zoom
        var imgCenterX = (centerX - PosX) / oldScale;
        var imgCenterY = (centerY - PosY) / oldScale;

        PosX = centerX - imgCenterX * newScale;
        PosY = centerY - imgCenterY * newScale;
        Scale = newScale;

        ClampPosition();
        await SetTransformAsync();
    }

    [JSInvokable]
    public async Task OnWindowResize()
    {
        if (isDisposed) return;

        var currentState = GetCurrentCropState();
        var originalSize = (CropWidth, CropHeight);

        await CalculateOptimalSize();

        if (HasSizeChanged(originalSize))
        {
            AdjustCropStateForNewSize(currentState, originalSize);
            StateHasChanged();
            await Task.Delay(10);
            await SetTransformAsync();
        }
    }

    private async Task InitializeCropper(double originalWidth, double originalHeight)
    {
        var cropperInfo = await JS.InvokeAsync<CropperInitInfo>("initInstagramStyleCropperInfo", ImageRef, Wrapper);
        UpdateImageDimensions(cropperInfo);

        if (HasExistingCropData() && HasSizeChanged((originalWidth, originalHeight)))
        {
            var currentState = GetCropStateFromData();
            AdjustCropStateForNewSize(currentState, (originalWidth, originalHeight));
        }
        else if (HasExistingCropData())
        {
            RestoreCropState();
        }
        else
        {
            InitializeDefaultState(cropperInfo);
        }

        ClampPosition();
        await SetTransformAsync();
        StateHasChanged();
    }

    private void UpdateImageDimensions(CropperInitInfo cropperInfo)
    {
        MinScale = cropperInfo.MinScale;
        ImgWidth = cropperInfo.ImgWidth;
        ImgHeight = cropperInfo.ImgHeight;
        CropWidth = cropperInfo.CropWidth;
        CropHeight = cropperInfo.CropHeight;
    }

    private CropState GetCurrentCropState() => new(PosX, PosY, Scale, ZoomValue, CropWidth, CropHeight);
    private CropState GetCropStateFromData() => new(CropData.PosX, CropData.PosY, CropData.Scale, CropData.ZoomValue, CropData.PreviewWidth, CropData.PreviewHeight);

    private bool HasExistingCropData() => CropData.Scale > 0 || CropData.PosX != 0 || CropData.PosY != 0 || CropData.ZoomValue > 0;
    private bool HasSizeChanged((double width, double height) originalSize) =>
        Math.Abs(originalSize.width - CropWidth) > 1 || Math.Abs(originalSize.height - CropHeight) > 1;

    private void RestoreCropState()
    {
        Scale = CropData.Scale;
        ZoomValue = CropData.ZoomValue;
        PosX = CropData.PosX;
        PosY = CropData.PosY;
    }

    private void InitializeDefaultState(CropperInitInfo cropperInfo)
    {
        Scale = MinScale;
        ZoomValue = 0;
        PosX = cropperInfo.PosX;
        PosY = cropperInfo.PosY;
    }

    private void AdjustCropStateForNewSize(CropState currentState, (double width, double height) originalSize)
    {
        var widthRatio = CropWidth / originalSize.width;
        var heightRatio = CropHeight / originalSize.height;

        // Adjust position proportionally
        PosX = currentState.PosX * widthRatio;
        PosY = currentState.PosY * heightRatio;

        // Adjust scale proportionally
        var originalMinScale = Math.Max(originalSize.width / ImgWidth, originalSize.height / ImgHeight);
        var newMinScale = Math.Max(CropWidth / ImgWidth, CropHeight / ImgHeight);
        var scaleRatio = currentState.Scale / originalMinScale;

        Scale = newMinScale * scaleRatio;
        MinScale = newMinScale;

        // Recalculate zoom value
        var normalizedScale = Math.Max(0, Math.Min(1, (Scale - MinScale) / (MinScale * ZoomRange - MinScale)));
        ZoomValue = normalizedScale * 100;

        ClampPosition();
    }

    private async Task SetTransformAsync()
    {
        await JS.InvokeVoidAsync("setCropperTransform", ImageRef, PosX, PosY, Scale);
    }

    private void OnPointerDown(PointerEventArgs e)
    {
        IsDragging = true;
        StartX = e.ClientX - PosX;
        StartY = e.ClientY - PosY;
    }

    private async void OnPointerMove(PointerEventArgs e)
    {
        if (!IsDragging) return;
        PosX = e.ClientX - StartX;
        PosY = e.ClientY - StartY;
        ClampPosition();
        await SetTransformAsync();
    }

    private async void OnPointerUp(PointerEventArgs e)
    {
        IsDragging = false;
        await SetTransformAsync();
    }

    private void ClampPosition()
    {
        var minX = CropWidth - ImgWidth * Scale;
        var minY = CropHeight - ImgHeight * Scale;
        PosX = Math.Min(0, Math.Max(minX, PosX));
        PosY = Math.Min(0, Math.Max(minY, PosY));
    }

    private async Task ConfirmCrop()
    {
        var cropData = new CropDataModel
        {
            PosX = PosX,
            PosY = PosY,
            Scale = Scale,
            ZoomValue = ZoomValue,
            PreviewWidth = CropWidth,
            PreviewHeight = CropHeight
        };

        await OnConfirm.InvokeAsync(cropData);
    }

    public async ValueTask DisposeAsync()
    {
        isDisposed = true;
        if (dotNetRef != null)
        {
            await JS.InvokeVoidAsync("removeWindowResizeListener");
            dotNetRef.Dispose();
        }
    }

    private record CropState(double PosX, double PosY, double Scale, double ZoomValue, double PreviewWidth, double PreviewHeight);

    private class CropperInitInfo
    {
        public double MinScale { get; set; }
        public double PosX { get; set; }
        public double PosY { get; set; }
        public double ImgWidth { get; set; }
        public double ImgHeight { get; set; }
        public double CropWidth { get; set; }
        public double CropHeight { get; set; }
    }

    private class WindowSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<style>
    .module-shade {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 1000;
    }

    .module {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        background: white;
        padding: 20px;
        border-radius: 10px;
        max-width: 90vw;
        max-height: 85vh;
        overflow: visible;
    }

    .cropper-wrapper {
        position: relative;
        overflow: hidden;
        touch-action: none;
        user-select: none;
    }

    .crop-image {
        position: absolute;
        top: 0;
        left: 0;
        cursor: grab;
        transform-origin: top left;
        -webkit-user-drag: none;
        user-drag: none;
    }

        .crop-image:active {
            cursor: grabbing;
        }

    .crop-box {
        pointer-events: none;
    }

    .zoom-slider-wrapper {
        margin: 15px auto;
    }

        .zoom-slider-wrapper input[type="range"] {
            width: 100%;
        }

    .module-button {
        border: 1px solid;
        background: #f8f9fa;
        cursor: pointer;
        padding: 10px 20px;
        border-radius: 4px;
        min-width: 80px;
    }

    .button-container {
        text-align: center;
    }
</style>

<script>
    let windowResizeListener = null;
    let dotNetHelper = null;
    let resizeTimeout = null;

    window.getWindowSize = () => {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        };
    };

    window.setupWindowResizeListener = (dotNetRef) => {
        dotNetHelper = dotNetRef;

        if (windowResizeListener) {
            window.removeEventListener('resize', windowResizeListener);
        }

        windowResizeListener = () => {
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            resizeTimeout = setTimeout(() => {
                if (dotNetHelper) {
                    dotNetHelper.invokeMethodAsync('OnWindowResize');
                }
            }, 150);
        };

        window.addEventListener('resize', windowResizeListener);
    };

    window.removeWindowResizeListener = () => {
        if (windowResizeListener) {
            window.removeEventListener('resize', windowResizeListener);
            windowResizeListener = null;
        }
        if (resizeTimeout) {
            clearTimeout(resizeTimeout);
            resizeTimeout = null;
        }
        dotNetHelper = null;
    };

    window.initInstagramStyleCropperInfo = (img, wrapper) => {
        return new Promise(resolve => {
            function getInfo() {
                const cropWidth = wrapper.clientWidth || 1;
                const cropHeight = wrapper.clientHeight || 1;
                const imgWidth = img.naturalWidth || 1;
                const imgHeight = img.naturalHeight || 1;
                const minScale = Number(Math.max(cropWidth / imgWidth, cropHeight / imgHeight)) || 1;
                const scale = Number(minScale);
                const posX = Number((cropWidth - imgWidth * scale) / 2) || 0;
                const posY = Number((cropHeight - imgHeight * scale) / 2) || 0;
                resolve({
                    minScale: minScale,
                    posX: posX,
                    posY: posY,
                    imgWidth: imgWidth,
                    imgHeight: imgHeight,
                    cropWidth: cropWidth,
                    cropHeight: cropHeight
                });
            }
            if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
                getInfo();
            } else {
                img.onload = getInfo;
            }
        });
    };

    window.setCropperTransform = (img, posX, posY, scale) => {
        img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    };
</script>