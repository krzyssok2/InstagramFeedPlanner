<div class="module-shade">
    <div class="module">
        <div class="cropper-wrapper" @ref="Wrapper"
             @onpointerdown="OnPointerDown"
             @onpointermove="OnPointerMove"
             @onpointerup="OnPointerUp"
             @onpointerleave="OnPointerUp"
             style="width: @(CropWidth)px; height: @(CropHeight)px;">
            <div class="crop-box"></div>
            <img @ref="ImageRef" src="@Src" class="crop-image" />
        </div>

        <div class="zoom-slider-wrapper" style="width: @(CropWidth)px;">
            <input type="range" min="0" max="100" value="@ZoomValue" @oninput="OnSliderChanged" />
        </div>

        <div class="button-container">
            <button class="module-button" @onclick="ConfirmCrop">Confirm</button>
            <button class="module-button" @onclick="() => OnCancel.InvokeAsync()">Cancel</button>
        </div>
        @if (CroppedImageDataUrl != null)
        {
            <img src="@CroppedImageDataUrl" style="max-width:200px;max-height:200px;" />
        }
    </div>
</div>

@implements IAsyncDisposable
@using InstagramFeedPlanner.Components
@using InstagramFeedPlanner.Models

@code {
    [Parameter] public string Src { get; set; } = "";
    [Parameter] public EventCallback<(string croppedUrl, CropDataModel cropData)> OnConfirm { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public CropDataModel CropData { get; set; } = new CropDataModel();
    [Parameter] public double AspectRatio { get; set; } = 0.75; // Default Instagram aspect ratio (3:4)

    private ElementReference ImageRef;
    private ElementReference Wrapper;

    private double ZoomValue { get; set; } = 0;
    private double Scale { get; set; } = 1;
    private double MinScale { get; set; } = 1;
    private double PosX { get; set; } = 0;
    private double PosY { get; set; } = 0;
    private bool IsDragging { get; set; } = false;
    private double StartX { get; set; }
    private double StartY { get; set; } = 0;
    private double ImgWidth { get; set; }
    private double ImgHeight { get; set; }
    private double CropWidth { get; set; } = 400;
    private double CropHeight { get; set; } = 500;

    private string? CroppedImageDataUrl;

    [Inject] private IJSRuntime JS { get; set; } = default!;

    private DotNetObjectReference<AspectCropper>? dotNetRef;
    private bool isDisposed = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);

            // Store original preview dimensions from crop data
            var originalPreviewWidth = CropData.PreviewWidth > 0 ? CropData.PreviewWidth : 400;
            var originalPreviewHeight = CropData.PreviewHeight > 0 ? CropData.PreviewHeight : 500;

            // Calculate optimal size first
            await CalculateOptimalSize();

            // Set up window resize listener
            await JS.InvokeVoidAsync("setupWindowResizeListener", dotNetRef);

            // Force re-render with new dimensions before initializing cropper
            StateHasChanged();

            // Small delay to ensure DOM is updated
            await Task.Delay(10);

            await InitializeCropper(originalPreviewWidth, originalPreviewHeight);
        }
    }

    private async Task CalculateOptimalSize()
    {
        try
        {
            var windowSize = await JS.InvokeAsync<WindowSize>("getWindowSize");

            // Reserve more space for UI elements to prevent scrollbars
            var availableWidth = windowSize.Width - 120;
            var availableHeight = windowSize.Height - 280; 

            // Define size ranges
            var minWidth = 280;
            var maxWidth = 600;
            var minHeight = 350;
            var maxHeight = 750;

            // Calculate optimal dimensions based on available space
            var optimalWidth = Math.Min(Math.Max(availableWidth, minWidth), maxWidth);
            var optimalHeight = optimalWidth / AspectRatio;

            // Adjust if height exceeds available space
            if (optimalHeight > availableHeight)
            {
                optimalHeight = Math.Min(Math.Max(availableHeight, minHeight), maxHeight);
                optimalWidth = optimalHeight * AspectRatio;
            }

            // Final safety check - ensure we don't exceed 80% of viewport
            var maxSafeWidth = windowSize.Width * 0.8;
            var maxSafeHeight = windowSize.Height * 0.6;

            if (optimalWidth > maxSafeWidth)
            {
                optimalWidth = maxSafeWidth;
                optimalHeight = optimalWidth / AspectRatio;
            }

            if (optimalHeight > maxSafeHeight)
            {
                optimalHeight = maxSafeHeight;
                optimalWidth = optimalHeight * AspectRatio;
            }

            CropWidth = optimalWidth;
            CropHeight = optimalHeight;
        }
        catch
        {
            CropWidth = 400;
            CropHeight = 500;
        }
    }

    private async Task OnSliderChanged(ChangeEventArgs e)
    {
        var oldScale = Scale;
        ZoomValue = Convert.ToDouble(e.Value);
        var maxScale = MinScale * 3;
        var newScale = MinScale + ((maxScale - MinScale) * (ZoomValue / 100));

        // Center of crop box
        var centerX = CropWidth / 2.0;
        var centerY = CropHeight / 2.0;

        // Image point under center before zoom
        var imgCenterX = (centerX - PosX) / oldScale;
        var imgCenterY = (centerY - PosY) / oldScale;

        // New position so same image point stays under center
        PosX = centerX - imgCenterX * newScale;
        PosY = centerY - imgCenterY * newScale;
        Scale = newScale;
        ClampPosition();
        await SetTransformAsync();
    }

    [JSInvokable]
    public async Task OnWindowResize()
    {
        if (isDisposed) return;

        // Store current crop state before resizing
        var currentCropData = new CropDataModel
        {
            PosX = PosX,
            PosY = PosY,
            Scale = Scale,
            ZoomValue = ZoomValue,
            PreviewWidth = CropWidth,
            PreviewHeight = CropHeight
        };

        var originalWidth = CropWidth;
        var originalHeight = CropHeight;

        // Recalculate optimal size
        await CalculateOptimalSize();

        // Only adjust if size actually changed
        if (Math.Abs(originalWidth - CropWidth) > 1 || Math.Abs(originalHeight - CropHeight) > 1)
        {
            // Temporarily set crop data to the current state for adjustment
            CropData = currentCropData;

            // Adjust all crop values for the new preview size
            AdjustCropDataForNewPreviewSize(originalWidth, originalHeight);

            // Force re-render with new dimensions
            StateHasChanged();
            await Task.Delay(10);

            // Update the image transform with adjusted values
            await SetTransformAsync();
        }
    }

    private async Task InitializeCropper(double originalPreviewWidth, double originalPreviewHeight)
    {
        var cropperInfo = await JS.InvokeAsync<CropperInitInfo>("initInstagramStyleCropperInfo", ImageRef, Wrapper);
        MinScale = cropperInfo.MinScale;
        ImgWidth = cropperInfo.ImgWidth;
        ImgHeight = cropperInfo.ImgHeight;
        CropWidth = cropperInfo.CropWidth;
        CropHeight = cropperInfo.CropHeight;

        // Adjust crop data if preview size has changed
        if (HasExistingCropData() && (Math.Abs(originalPreviewWidth - CropWidth) > 1 || Math.Abs(originalPreviewHeight - CropHeight) > 1))
        {
            AdjustCropDataForNewPreviewSize(originalPreviewWidth, originalPreviewHeight);
        }
        else if (HasExistingCropData())
        {
            // Use existing crop data as-is
            Scale = CropData.Scale;
            ZoomValue = CropData.ZoomValue;
            PosX = CropData.PosX;
            PosY = CropData.PosY;
        }
        else
        {
            // Initialize with default values
            Scale = MinScale;
            ZoomValue = 0;
            PosX = cropperInfo.PosX;
            PosY = cropperInfo.PosY;
        }

        ClampPosition();
        await SetTransformAsync();
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        isDisposed = true;
        if (dotNetRef != null)
        {
            await JS.InvokeVoidAsync("removeWindowResizeListener");
            dotNetRef.Dispose();
        }
    }

    private bool HasExistingCropData()
    {
        return CropData.Scale > 0 || CropData.PosX != 0 || CropData.PosY != 0 || CropData.ZoomValue > 0;
    }

    private void AdjustCropDataForNewPreviewSize(double originalWidth, double originalHeight)
    {
        // Calculate scaling factors for the preview size change
        var widthRatio = CropWidth / originalWidth;
        var heightRatio = CropHeight / originalHeight;

        // Adjust position values proportionally
        PosX = CropData.PosX * widthRatio;
        PosY = CropData.PosY * heightRatio;

        // Calculate original and new minimum scales
        var originalMinScale = Math.Max(originalWidth / ImgWidth, originalHeight / ImgHeight);
        var newMinScale = Math.Max(CropWidth / ImgWidth, CropHeight / ImgHeight);

        // Maintain the same scale ratio relative to minimum scale
        var scaleRatio = CropData.Scale / originalMinScale;
        Scale = newMinScale * scaleRatio;

        // Update MinScale for the new preview size
        MinScale = newMinScale;

        // Recalculate zoom value based on the new scale range
        var newMaxScale = newMinScale * 3;
        var normalizedScale = Math.Max(0, Math.Min(1, (Scale - newMinScale) / (newMaxScale - newMinScale)));
        ZoomValue = normalizedScale * 100;

        // Ensure position stays within valid bounds after scaling
        ClampPosition();

        // Debug logging (can be removed in production)
        Console.WriteLine($"Resize adjustment: {originalWidth}x{originalHeight} -> {CropWidth}x{CropHeight}");
        Console.WriteLine($"Scale: {CropData.Scale} -> {Scale} (MinScale: {originalMinScale} -> {newMinScale})");
        Console.WriteLine($"Position: ({CropData.PosX}, {CropData.PosY}) -> ({PosX}, {PosY})");
        Console.WriteLine($"Zoom: {CropData.ZoomValue} -> {ZoomValue}");
    }

    private async Task SetTransformAsync()
    {
        await JS.InvokeVoidAsync("setCropperTransform", ImageRef, PosX, PosY, Scale);
    }

    private void OnPointerDown(PointerEventArgs e)
    {
        IsDragging = true;
        StartX = e.ClientX - PosX;
        StartY = e.ClientY - PosY;
    }

    private async void OnPointerMove(PointerEventArgs e)
    {
        if (!IsDragging) return;
        PosX = e.ClientX - StartX;
        PosY = e.ClientY - StartY;
        ClampPosition();
        await SetTransformAsync();
    }

    private async void OnPointerUp(PointerEventArgs e)
    {
        IsDragging = false;
        await SetTransformAsync();
    }

    private void ClampPosition()
    {
        var minX = CropWidth - ImgWidth * Scale;
        var minY = CropHeight - ImgHeight * Scale;
        PosX = Math.Min(0, Math.Max(minX, PosX));
        PosY = Math.Min(0, Math.Max(minY, PosY));
    }

    private async Task GetCroppedImageAsync()
    {
        CroppedImageDataUrl = await JS.InvokeAsync<string>("getCroppedImageDataUrl", ImageRef, Wrapper, PosX, PosY, Scale);
        StateHasChanged();
    }

    private async Task ConfirmCrop()
    {
        if (CroppedImageDataUrl == null)
        {
            await GetCroppedImageAsync();
        }

        if (CroppedImageDataUrl != null)
        {
            var cropData = new CropDataModel
            {
                PosX = PosX,
                PosY = PosY,
                Scale = Scale,
                ZoomValue = ZoomValue,
                PreviewWidth = CropWidth,
                PreviewHeight = CropHeight
            };
            await OnConfirm.InvokeAsync((CroppedImageDataUrl, cropData));
        }
    }

    private class CropperInitInfo
    {
        public double MinScale { get; set; }
        public double PosX { get; set; }
        public double PosY { get; set; }
        public double ImgWidth { get; set; }
        public double ImgHeight { get; set; }
        public double CropWidth { get; set; }
        public double CropHeight { get; set; }
    }

    private class WindowSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<style>
    .module-shade {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 1000;
    }

    .module {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        background: white;
        padding: 20px;
        border-radius: 10px;
        max-width: 90vw;
        max-height: 85vh;
        overflow: visible;
    }

    .cropper-wrapper {
        position: relative;
        overflow: hidden;
        touch-action: none;
        user-select: none;
    }

    .crop-image {
        position: absolute;
        top: 0;
        left: 0;
        cursor: grab;
        transform-origin: top left;
        -webkit-user-drag: none;
        user-drag: none;
    }

        .crop-image:active {
            cursor: grabbing;
        }

    .crop-box {
        pointer-events: none;
    }

    .zoom-slider-wrapper {
        margin: 15px auto;
    }

        .zoom-slider-wrapper input[type="range"] {
            width: 100%;
        }


    .module-button {
        border: 1px solid;
        background: #f8f9fa;
        cursor: pointer;
        padding: 10px 20px;
        border-radius: 4px;
        min-width: 80px;
    }

    .button-container {
        text-align: center;
    }
</style>

<script>
    let windowResizeListener = null;
    let dotNetHelper = null;
    let resizeTimeout = null;

    window.getWindowSize = () => {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        };
    };

    window.setupWindowResizeListener = (dotNetRef) => {
        dotNetHelper = dotNetRef;

        // Remove existing listener if any
        if (windowResizeListener) {
            window.removeEventListener('resize', windowResizeListener);
        }

        // Create debounced resize handler
        windowResizeListener = () => {
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            resizeTimeout = setTimeout(() => {
                if (dotNetHelper) {
                    dotNetHelper.invokeMethodAsync('OnWindowResize');
                }
            }, 150); // Debounce resize events
        };

        window.addEventListener('resize', windowResizeListener);
    };

    window.removeWindowResizeListener = () => {
        if (windowResizeListener) {
            window.removeEventListener('resize', windowResizeListener);
            windowResizeListener = null;
        }
        if (resizeTimeout) {
            clearTimeout(resizeTimeout);
            resizeTimeout = null;
        }
        dotNetHelper = null;
    };

    window.initInstagramStyleCropperInfo = (img, wrapper) => {
        return new Promise(resolve => {
            function getInfo() {
                const cropWidth = wrapper.clientWidth || 1;
                const cropHeight = wrapper.clientHeight || 1;
                const imgWidth = img.naturalWidth || 1;
                const imgHeight = img.naturalHeight || 1;
                const minScale = Number(Math.max(cropWidth / imgWidth, cropHeight / imgHeight)) || 1;
                const scale = Number(minScale);
                const posX = Number((cropWidth - imgWidth * scale) / 2) || 0;
                const posY = Number((cropHeight - imgHeight * scale) / 2) || 0;
                resolve({
                    minScale: minScale,
                    posX: posX,
                    posY: posY,
                    imgWidth: imgWidth,
                    imgHeight: imgHeight,
                    cropWidth: cropWidth,
                    cropHeight: cropHeight
                });
            }
            if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
                getInfo();
            } else {
                img.onload = getInfo;
            }
        });
    };

    window.setCropperTransform = (img, posX, posY, scale) => {
        img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    };

    window.getCroppedImageDataUrl = (img, wrapper, posX, posY, scale) => {
        const cropWidth = wrapper.clientWidth;
        const cropHeight = wrapper.clientHeight;
        const canvas = document.createElement('canvas');
        canvas.width = cropWidth;
        canvas.height = cropHeight;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, cropWidth, cropHeight);
        ctx.save();
        ctx.translate(posX, posY);
        ctx.scale(scale, scale);
        ctx.drawImage(img, 0, 0);
        ctx.restore();
        return canvas.toDataURL('image/jpeg', 0.95);
    };
</script>