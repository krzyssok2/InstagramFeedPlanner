<div class="module-shade">
    <div class="module">
        <div class="cropper-wrapper" @ref="Wrapper"
             @onpointerdown="OnPointerDown"
             @onpointermove="OnPointerMove"
             @onpointerup="OnPointerUp"
             @onpointerleave="OnPointerUp"
             style="width: @(CropWidth)px; height: @(CropHeight)px;">
            <div class="crop-box"></div>
            <img @ref="ImageRef" src="@Src" class="crop-image" />
        </div>

        <div class="zoom-slider-wrapper" style="width: @(CropWidth)px;">
            <input type="range" min="0" max="100" value="@ZoomValue" @oninput="OnSliderChanged" />
        </div>

        <div class="button-container">
            <button class="module-button" @onclick="ConfirmCrop">Confirm</button>
            <button class="module-button" @onclick="() => OnCancel.InvokeAsync()">Cancel</button>
        </div>
    </div>
</div>

@implements IAsyncDisposable
@using InstagramFeedPlanner.Components
@using InstagramFeedPlanner.Models

@code {
    [Parameter] public string Src { get; set; } = "";
    [Parameter] public EventCallback<CropDataModel> OnConfirm { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public CropDataModel CropData { get; set; } = new CropDataModel();
    [Parameter] public double AspectRatio { get; set; } = 0.75; // Default Instagram aspect ratio (3:4)

    // Configuration constants based on aspect ratio
    private const double BaseWidth = 400;
    private const double ViewportWidthRatio = 0.8;
    private const double ViewportHeightRatio = 0.6;
    private const double UISpaceWidth = 120;
    private const double UISpaceHeight = 280;
    private const double ZoomMultiplier = 3.0;
    private const double MinWidthRatio = 0.7; // BaseWidth * 0.7 = 280
    private const double MaxWidthRatio = 1.5;  // BaseWidth * 1.5 = 600

    private ElementReference ImageRef;
    private ElementReference Wrapper;

    private double ZoomValue { get; set; } = 0;
    private double Scale { get; set; } = 1;
    private double MinScale { get; set; } = 1;
    private double PosX { get; set; } = 0;
    private double PosY { get; set; } = 0;
    private bool IsDragging { get; set; } = false;
    private double StartX { get; set; }
    private double StartY { get; set; } = 0;
    private double ImgWidth { get; set; }
    private double ImgHeight { get; set; }
    private double CropWidth { get; set; }
    private double CropHeight { get; set; }

    private string? CroppedImageDataUrl;

    [Inject] private IJSRuntime JS { get; set; } = default!;

    private DotNetObjectReference<AspectCropper>? dotNetRef;
    private bool isDisposed = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            var originalPreviewWidth = CropData.PreviewWidth > 0 ? CropData.PreviewWidth : BaseWidth;
            var originalPreviewHeight = CropData.PreviewHeight > 0 ? CropData.PreviewHeight : BaseWidth / AspectRatio;

            await CalculateOptimalSize();
            await JS.InvokeVoidAsync("setupWindowResizeListener", dotNetRef);
            StateHasChanged();
            await Task.Delay(10);
            await InitializeCropper(originalPreviewWidth, originalPreviewHeight);
        }
    }

    private async Task CalculateOptimalSize()
    {
        try
        {
            var windowSize = await JS.InvokeAsync<WindowSize>("getWindowSize");
            var availableWidth = windowSize.Width - UISpaceWidth;
            var availableHeight = windowSize.Height - UISpaceHeight;

            // Calculate size bounds based on aspect ratio
            var minWidth = BaseWidth * MinWidthRatio;
            var maxWidth = BaseWidth * MaxWidthRatio;
            var minHeight = minWidth / AspectRatio;
            var maxHeight = maxWidth / AspectRatio;

            // Start with optimal width based on available space
            var optimalWidth = Math.Min(Math.Max(availableWidth, minWidth), maxWidth);
            var optimalHeight = optimalWidth / AspectRatio;

            // Adjust if height exceeds available space
            if (optimalHeight > availableHeight)
            {
                optimalHeight = Math.Min(Math.Max(availableHeight, minHeight), maxHeight);
                optimalWidth = optimalHeight * AspectRatio;
            }

            // Final viewport safety check
            var maxSafeWidth = windowSize.Width * ViewportWidthRatio;
            var maxSafeHeight = windowSize.Height * ViewportHeightRatio;

            if (optimalWidth > maxSafeWidth)
            {
                optimalWidth = maxSafeWidth;
                optimalHeight = optimalWidth / AspectRatio;
            }

            if (optimalHeight > maxSafeHeight)
            {
                optimalHeight = maxSafeHeight;
                optimalWidth = optimalHeight * AspectRatio;
            }

            CropWidth = optimalWidth;
            CropHeight = optimalHeight;
        }
        catch
        {
            // Fallback to base dimensions
            CropWidth = BaseWidth;
            CropHeight = BaseWidth / AspectRatio;
        }
    }

    private async Task OnSliderChanged(ChangeEventArgs e)
    {
        var oldScale = Scale;
        ZoomValue = Convert.ToDouble(e.Value);
        var maxScale = MinScale * ZoomMultiplier;
        var newScale = MinScale + ((maxScale - MinScale) * (ZoomValue / 100));

        // Center zoom on crop box center
        var centerX = CropWidth / 2.0;
        var centerY = CropHeight / 2.0;

        // Maintain same image point under center during zoom
        var imgCenterX = (centerX - PosX) / oldScale;
        var imgCenterY = (centerY - PosY) / oldScale;

        PosX = centerX - imgCenterX * newScale;
        PosY = centerY - imgCenterY * newScale;
        Scale = newScale;

        ClampPosition();
        await SetTransformAsync();
    }

    [JSInvokable]
    public async Task OnWindowResize()
    {
        if (isDisposed) return;

        var currentCropData = new CropDataModel
        {
            PosX = PosX,
            PosY = PosY,
            Scale = Scale,
            ZoomValue = ZoomValue,
            PreviewWidth = CropWidth,
            PreviewHeight = CropHeight
        };

        var originalWidth = CropWidth;
        var originalHeight = CropHeight;

        await CalculateOptimalSize();

        // Only adjust if size actually changed
        if (Math.Abs(originalWidth - CropWidth) > 1 || Math.Abs(originalHeight - CropHeight) > 1)
        {
            CropData = currentCropData;
            AdjustCropDataForNewPreviewSize(originalWidth, originalHeight);
            StateHasChanged();
            await Task.Delay(10);
            await SetTransformAsync();
        }
    }

    private async Task InitializeCropper(double originalPreviewWidth, double originalPreviewHeight)
    {
        var cropperInfo = await JS.InvokeAsync<CropperInitInfo>("initInstagramStyleCropperInfo", ImageRef, Wrapper);
        MinScale = cropperInfo.MinScale;
        ImgWidth = cropperInfo.ImgWidth;
        ImgHeight = cropperInfo.ImgHeight;
        CropWidth = cropperInfo.CropWidth;
        CropHeight = cropperInfo.CropHeight;

        // Handle existing crop data or initialize defaults
        if (HasExistingCropData() && HasPreviewSizeChanged(originalPreviewWidth, originalPreviewHeight))
        {
            AdjustCropDataForNewPreviewSize(originalPreviewWidth, originalPreviewHeight);
        }
        else if (HasExistingCropData())
        {
            RestoreExistingCropData();
        }
        else
        {
            InitializeDefaultCropData(cropperInfo);
        }

        ClampPosition();
        await SetTransformAsync();
        StateHasChanged();
    }

    private bool HasExistingCropData() => CropData.Scale > 0 || CropData.PosX != 0 || CropData.PosY != 0 || CropData.ZoomValue > 0;

    private bool HasPreviewSizeChanged(double originalWidth, double originalHeight) =>
        Math.Abs(originalWidth - CropWidth) > 1 || Math.Abs(originalHeight - CropHeight) > 1;

    private void RestoreExistingCropData()
    {
        Scale = CropData.Scale;
        ZoomValue = CropData.ZoomValue;
        PosX = CropData.PosX;
        PosY = CropData.PosY;
    }

    private void InitializeDefaultCropData(CropperInitInfo cropperInfo)
    {
        Scale = MinScale;
        ZoomValue = 0;
        PosX = cropperInfo.PosX;
        PosY = cropperInfo.PosY;
    }

    private void AdjustCropDataForNewPreviewSize(double originalWidth, double originalHeight)
    {
        // Calculate proportional adjustments
        var widthRatio = CropWidth / originalWidth;
        var heightRatio = CropHeight / originalHeight;

        // Adjust position proportionally
        PosX = CropData.PosX * widthRatio;
        PosY = CropData.PosY * heightRatio;

        // Calculate scale adjustments
        var originalMinScale = Math.Max(originalWidth / ImgWidth, originalHeight / ImgHeight);
        var newMinScale = Math.Max(CropWidth / ImgWidth, CropHeight / ImgHeight);
        var scaleRatio = CropData.Scale / originalMinScale;

        Scale = newMinScale * scaleRatio;
        MinScale = newMinScale;

        // Recalculate zoom value for new scale range
        var newMaxScale = newMinScale * ZoomMultiplier;
        var normalizedScale = Math.Max(0, Math.Min(1, (Scale - newMinScale) / (newMaxScale - newMinScale)));
        ZoomValue = normalizedScale * 100;

        ClampPosition();
    }

    private async Task SetTransformAsync()
    {
        await JS.InvokeVoidAsync("setCropperTransform", ImageRef, PosX, PosY, Scale);
    }

    private void OnPointerDown(PointerEventArgs e)
    {
        IsDragging = true;
        StartX = e.ClientX - PosX;
        StartY = e.ClientY - PosY;
    }

    private async void OnPointerMove(PointerEventArgs e)
    {
        if (!IsDragging) return;
        PosX = e.ClientX - StartX;
        PosY = e.ClientY - StartY;
        ClampPosition();
        await SetTransformAsync();
    }

    private async void OnPointerUp(PointerEventArgs e)
    {
        IsDragging = false;
        await SetTransformAsync();
    }

    private void ClampPosition()
    {
        var minX = CropWidth - ImgWidth * Scale;
        var minY = CropHeight - ImgHeight * Scale;
        PosX = Math.Min(0, Math.Max(minX, PosX));
        PosY = Math.Min(0, Math.Max(minY, PosY));
    }

    private async Task ConfirmCrop()
    {
        var cropData = new CropDataModel
        {
            PosX = PosX,
            PosY = PosY,
            Scale = Scale,
            ZoomValue = ZoomValue,
            PreviewWidth = CropWidth,
            PreviewHeight = CropHeight
        };

        await OnConfirm.InvokeAsync(cropData);
    }

    public async ValueTask DisposeAsync()
    {
        isDisposed = true;
        if (dotNetRef != null)
        {
            await JS.InvokeVoidAsync("removeWindowResizeListener");
            dotNetRef.Dispose();
        }
    }

    private class CropperInitInfo
    {
        public double MinScale { get; set; }
        public double PosX { get; set; }
        public double PosY { get; set; }
        public double ImgWidth { get; set; }
        public double ImgHeight { get; set; }
        public double CropWidth { get; set; }
        public double CropHeight { get; set; }
    }

    private class WindowSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<style>
    .module-shade {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 1000;
    }

    .module {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        background: white;
        padding: 20px;
        border-radius: 10px;
        max-width: 90vw;
        max-height: 85vh;
        overflow: visible;
    }

    .cropper-wrapper {
        position: relative;
        overflow: hidden;
        touch-action: none;
        user-select: none;
    }

    .crop-image {
        position: absolute;
        top: 0;
        left: 0;
        cursor: grab;
        transform-origin: top left;
        -webkit-user-drag: none;
        user-drag: none;
    }

        .crop-image:active {
            cursor: grabbing;
        }

    .crop-box {
        pointer-events: none;
    }

    .zoom-slider-wrapper {
        margin: 15px auto;
    }

        .zoom-slider-wrapper input[type="range"] {
            width: 100%;
        }

    .module-button {
        border: 1px solid;
        background: #f8f9fa;
        cursor: pointer;
        padding: 10px 20px;
        border-radius: 4px;
        min-width: 80px;
    }

    .button-container {
        text-align: center;
    }
</style>

<script>
    let windowResizeListener = null;
    let dotNetHelper = null;
    let resizeTimeout = null;

    window.getWindowSize = () => {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        };
    };

    window.setupWindowResizeListener = (dotNetRef) => {
        dotNetHelper = dotNetRef;

        if (windowResizeListener) {
            window.removeEventListener('resize', windowResizeListener);
        }

        windowResizeListener = () => {
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            resizeTimeout = setTimeout(() => {
                if (dotNetHelper) {
                    dotNetHelper.invokeMethodAsync('OnWindowResize');
                }
            }, 150);
        };

        window.addEventListener('resize', windowResizeListener);
    };

    window.removeWindowResizeListener = () => {
        if (windowResizeListener) {
            window.removeEventListener('resize', windowResizeListener);
            windowResizeListener = null;
        }
        if (resizeTimeout) {
            clearTimeout(resizeTimeout);
            resizeTimeout = null;
        }
        dotNetHelper = null;
    };

    window.initInstagramStyleCropperInfo = (img, wrapper) => {
        return new Promise(resolve => {
            function getInfo() {
                const cropWidth = wrapper.clientWidth || 1;
                const cropHeight = wrapper.clientHeight || 1;
                const imgWidth = img.naturalWidth || 1;
                const imgHeight = img.naturalHeight || 1;
                const minScale = Number(Math.max(cropWidth / imgWidth, cropHeight / imgHeight)) || 1;
                const scale = Number(minScale);
                const posX = Number((cropWidth - imgWidth * scale) / 2) || 0;
                const posY = Number((cropHeight - imgHeight * scale) / 2) || 0;
                resolve({
                    minScale: minScale,
                    posX: posX,
                    posY: posY,
                    imgWidth: imgWidth,
                    imgHeight: imgHeight,
                    cropWidth: cropWidth,
                    cropHeight: cropHeight
                });
            }
            if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
                getInfo();
            } else {
                img.onload = getInfo;
            }
        });
    };

    window.setCropperTransform = (img, posX, posY, scale) => {
        img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    };
</script>